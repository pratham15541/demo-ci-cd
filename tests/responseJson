"```json\n{\n  \"tests/createTestFiles.test.js\": \"const createTestFiles = require('../createTestFiles');\\nconst testCases = require('./createTestFiles.testCase.json');\\n\\nconst fs = require('fs');\\nconst path = require('path');\\n\\n// Mock fs and path modules\\njest.mock('fs', () => ({\\n  existsSync: jest.fn(),\\n  mkdirSync: jest.fn(),\\n  writeFileSync: jest.fn(),\\n  readFileSync: jest.fn(),\\n}));\\n\\njest.mock('path', () => ({\\n  join: jest.fn((...args) => args.filter(Boolean).join('/')), // Mock join to use '/' for consistent paths\\n  basename: jest.fn((p) => p.split('/').pop()), // Mock basename for consistent behavior\\n}));\\n\\ndescribe('createTestFiles', () => {\\n  let consoleErrorSpy;\\n  let consoleLogSpy;\\n\\n  beforeEach(() => {\\n    // Reset mocks before each test\\n    fs.existsSync.mockClear();\\n    fs.mkdirSync.mockClear();\\n    fs.writeFileSync.mockClear();\\n    path.join.mockClear();\\n    path.basename.mockClear();\\n\\n    consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});\\n    consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => {});\\n\\n    // Default mock behavior for fs.existsSync - assume folder doesn't exist by default\\n    fs.existsSync.mockReturnValue(false);\\n  });\\n\\n  afterEach(() => {\\n    consoleErrorSpy.mockRestore();\\n    consoleLogSpy.mockRestore();\\n  });\\n\\n  testCases.createTestFiles.forEach(testCase => {\\n    test(testCase.description, () => {\\n      // Setup specific mock behaviors for this test case\\n      if (testCase.expected.mockWriteFileError) {\\n        fs.writeFileSync.mockImplementationOnce(() => {\\n          throw new Error('Mock write error');\\n        });\\n      }\\n\\n      createTestFiles(...testCase.input);\\n\\n      // Assertions based on expected outcomes\\n      if (testCase.expected.noFsCalls) {\\n        expect(fs.existsSync).not.toHaveBeenCalled();\\n        expect(fs.mkdirSync).not.toHaveBeenCalled();\\n        expect(fs.writeFileSync).not.toHaveBeenCalled();\\n        expect(path.join).not.toHaveBeenCalled();\\n        expect(path.basename).not.toHaveBeenCalled();\\n      } else {\\n        const actualFolder = testCase.input[1] || 'tests'; // folder argument or default 'tests'\\n\\n        expect(fs.existsSync).toHaveBeenCalledWith(actualFolder);\\n        if (testCase.expected.mkdirCalls) {\\n          expect(fs.mkdirSync).toHaveBeenCalledTimes(testCase.expected.mkdirCalls.length);\\n          testCase.expected.mkdirCalls.forEach(call => {\\n            expect(fs.mkdirSync).toHaveBeenCalledWith(...call);\\n          });\\n        } else {\\n          // In our test setup, existsSync defaults to false, so mkdirSync is usually expected.\\n          // If it were explicitly `mockReturnValue(true)`, then mkdirSync would not be called.\\n          // For these 5 test cases, mkdirSync is expected to be called if it's in the `expected.mkdirCalls`.\\n        }\\n        \\n        // Handling file writing and associated path calls\\n        if (testCase.expected.writeFileCalls && testCase.expected.writeFileCalls.length > 0) {\\n          expect(fs.writeFileSync).toHaveBeenCalledTimes(testCase.expected.writeFileCalls.length);\\n          let expectedBasenameCalls = [];\\n          let expectedJoinCalls = [];\\n\\n          // Parse the input string to get original filenames (keys)\\n          const fileMap = typeof testCase.input[0] === 'string'\\n            ? JSON.parse(testCase.input[0].replace(/^```json\\\\s*|\\\\s*```$/g, ''))\\n            : testCase.input[0];\\n          \\n          Object.keys(fileMap).forEach(originalFilename => {\\n              expectedBasenameCalls.push([originalFilename]);\\n              const baseName = path.basename(originalFilename); // Use the mock path.basename to get expected value\\n              expectedJoinCalls.push([actualFolder, baseName]);\\n          });\\n\\n          // Check path.basename calls\\n          expect(path.basename).toHaveBeenCalledTimes(expectedBasenameCalls.length);\\n          expectedBasenameCalls.forEach(callArgs => {\\n              expect(path.basename).toHaveBeenCalledWith(...callArgs);\\n          });\\n\\n          // Check path.join calls\\n          expect(path.join).toHaveBeenCalledTimes(expectedJoinCalls.length);\\n          expectedJoinCalls.forEach(callArgs => {\\n              expect(path.join).toHaveBeenCalledWith(...callArgs);\\n          });\\n\\n          // Check fs.writeFileSync calls\\n          testCase.expected.writeFileCalls.forEach(call => {\\n            expect(fs.writeFileSync).toHaveBeenCalledWith(call[0], call[1], call[2]);\\n          });\\n\\n        } else { // No writeFileCalls\\n          expect(fs.writeFileSync).not.toHaveBeenCalled();\\n          expect(path.join).not.toHaveBeenCalled();\\n          expect(path.basename).not.toHaveBeenCalled();\\n        }\\n      }\\n\\n      // Check console logs\\n      if (testCase.expected.consoleLogs) {\\n        testCase.expected.consoleLogs.forEach(msg => {\\n          expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining(msg));\\n        });\\n      } else {\\n        expect(consoleLogSpy).not.toHaveBeenCalled();\\n      }\\n\\n      // Check console errors\\n      if (testCase.expected.consoleErrors) {\\n        testCase.expected.consoleErrors.forEach(msg => {\\n          expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining(msg));\\n        });\\n      } else {\\n        expect(consoleErrorSpy).not.toHaveBeenCalled();\\n      }\\n    });\\n  });\\n});\\n\",\n  \"tests/createTestFiles.testCase.json\": \"{\\n  \\\"createTestFiles\\\": [\\n    {\\n      \\\"input\\\": [\\n        \\\"{\\\\\\\"file1.txt\\\\\\\": \\\\\\\"hello\\\\\\\", \\\\\\\"sub/file2.json\\\\\\\": \\\\\\\"{\\\\\\\\\\\\\\\"data\\\\\\\\\\\\\\\":123}\\\\\\\"}\\\",\\n        \\\"output_dir\\\"\\n      ],\\n      \\\"expected\\\": {\\n        \\\"mkdirCalls\\\": [[\\\"output_dir\\\", {\\\"recursive\\\": true}]],\\n        \\\"writeFileCalls\\\": [\\n          [\\\"output_dir/file1.txt\\\", \\\"hello\\\", \\\"utf8\\\"],\\n          [\\\"output_dir/file2.json\\\", \\\"{\\\\n  \\\\\\\"data\\\\\\\": 123\\\\n}\\\", \\\"utf8\\\"]\\n        ],\\n        \\\"consoleLogs\\\": [\\n          \\\"Created folder: output_dir\\\",\\n          \\\"✅ Created/Updated file: output_dir/file1.txt\\\",\\n          \\\"✅ Created/Updated file: output_dir/file2.json\\\"\\n        ]\\n      },\\n      \\\"description\\\": \\\"should correctly create files from a valid JSON string input, including pretty-printing JSON content\\\"\\n    },\\n    {\\n      \\\"input\\\": [\\n        {},\\n        \\\"empty_dir\\\"\\n      ],\\n      \\\"expected\\\": {\\n        \\\"mkdirCalls\\\": [[\\\"empty_dir\\\", {\\\"recursive\\\": true}]],\\n        \\\"writeFileCalls\\\": [],\\n        \\\"consoleLogs\\\": [\\\"Created folder: empty_dir\\\"]\\n      },\\n      \\\"description\\\": \\\"should do nothing other than ensure folder exists when given an empty object\\\"\\n    },\\n    {\\n      \\\"input\\\": [\\n        \\\"{\\\\\\\"malformed.json\\\\\\\": \\\\\\\"{not json}\\\\\\\"}\\\",\\n        \\\"malformed_dir\\\"\\n      ],\\n      \\\"expected\\\": {\\n        \\\"mkdirCalls\\\": [[\\\"malformed_dir\\\", {\\\"recursive\\\": true}]],\\n        \\\"writeFileCalls\\\": [\\n          [\\\"malformed_dir/malformed.json\\\", \\\"{not json}\\\", \\\"utf8\\\"]\\n        ],\\n        \\\"consoleLogs\\\": [\\n          \\\"Created folder: malformed_dir\\\",\\n          \\\"Content for malformed.json is not valid JSON, using as-is\\\",\\n          \\\"✅ Created/Updated file: malformed_dir/malformed.json\\\"\\n        ]\\n      },\\n      \\\"description\\\": \\\"should write content as-is if it's a .json file with invalid JSON content\\\"\\n    },\\n    {\\n      \\\"input\\\": [\\n        \\\"invalid_json_string\\\",\\n        \\\"some_dir\\\"\\n      ],\\n      \\\"expected\\\": {\\n        \\\"consoleErrors\\\": [\\n          \\\"Failed to parse JSON:\\\",\\n          \\\"Input preview: invalid_json_string...\\\"\\n        ],\\n        \\\"noFsCalls\\\": true\\n      },\\n      \\\"description\\\": \\\"should log an error and return early for malformed JSON string input\\\"\\n    },\\n    {\\n      \\\"input\\\": [\\n        \\\"{\\\\\\\"error.txt\\\\\\\": \\\\\\\"content\\\\\\\"}\\\",\\n        \\\"error_dir\\\"\\n      ],\\n      \\\"expected\\\": {\\n        \\\"mockWriteFileError\\\": true,\\n        \\\"mkdirCalls\\\": [[\\\"error_dir\\\", {\\\"recursive\\\": true}]],\\n        \\\"writeFileCalls\\\": [\\n          [\\\"error_dir/error.txt\\\", \\\"content\\\", \\\"utf8\\\"]\\n        ],\\n        \\\"consoleErrors\\\": [\\n          \\\"❌ Failed to write file error_dir/error.txt:\\\",\\n          \\\"Mock write error\\\"\\n        ],\\n        \\\"consoleLogs\\\": [\\n          \\\"Created folder: error_dir\\\"\\n        ]\\n      },\\n      \\\"description\\\": \\\"should catch and log error if fs.writeFileSync fails\\\"\\n    }\\n  ]\\n}\"\n}\n```"