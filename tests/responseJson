"```json\n{\n  \"tests/addition.test.js\": \"const addition = require('../addition');\\nconst testCases = require('./addition.testCase.json');\\n\\ndescribe('addition', () => {\\n  testCases.addition.forEach(testCase => {\\n    test(testCase.description, () => {\\n      // Note: According to the example's strict output format for 'NaN' (string), \\n      // 'Infinity' is also represented as a string. \\n      // This means tests for actual number NaN/Infinity results from 'a/b' will fail \\n      // because 'NaN' (number) !== '\\\"NaN\\\"' (string) and 'Infinity' (number) !== '\\\"Infinity\\\"' (string).\\n      // For functional testing of number NaN/Infinity, expect().toBeNaN() or expect().toBe(Infinity) should be used.\\n      expect(addition(...testCase.input)).toBe(testCase.expected);\\n    });\\n  });\\n});\\n\",\n  \"tests/addition.testCase.json\": \"{\\n  \\\"addition\\\": [\\n    {\\\"input\\\": [6,2], \\\"expected\\\": 3, \\\"description\\\": \\\"should correctly divide two positive numbers\\\"},\\n    {\\\"input\\\": [5,0], \\\"expected\\\": \\\"Infinity\\\", \\\"description\\\": \\\"should return Infinity when dividing by zero\\\"},\\n    {\\\"input\\\": [-6,2], \\\"expected\\\": -3, \\\"description\\\": \\\"should correctly divide a negative number by a positive number\\\"},\\n    {\\\"input\\\": [0,5], \\\"expected\\\": 0, \\\"description\\\": \\\"should return zero when numerator is zero\\\"},\\n    {\\\"input\\\": [\\\"a\\\",2], \\\"expected\\\": \\\"NaN\\\", \\\"description\\\": \\\"should return NaN when inputs are not numbers\\\"}\\n  ]\\n}\"\n}\n```"