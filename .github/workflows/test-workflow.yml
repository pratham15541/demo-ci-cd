name: Send Files to Server

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  send_files:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 2
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18"

      - name: Get changed JS/TS files from last commit
        id: files
        run: |
          echo "=== Getting JS/TS files from last commit ==="

          # Get files from last commit only
          ALL_FILES=$(git show --pretty="" --name-only HEAD)

          # Filter only JS/TS files
          CHANGED_FILES=""
          for file in $ALL_FILES; do
            case "$file" in
              *.js|*.jsx|*.ts|*.tsx)
                if [ -f "$file" ]; then
                  CHANGED_FILES="$CHANGED_FILES $file"
                fi
                ;;
            esac
          done

          CHANGED_FILES=$(echo $CHANGED_FILES | xargs)
          echo "CHANGED_FILES=$CHANGED_FILES" >> $GITHUB_ENV
          echo "Detected JS/TS files from last commit: '$CHANGED_FILES'"

          if [ -z "$CHANGED_FILES" ]; then
            echo "HAS_FILES=false" >> $GITHUB_ENV
            echo "No JS/TS files in last commit"
          else
            echo "HAS_FILES=true" >> $GITHUB_ENV
            echo "Found JS/TS files to send"
          fi

      - name: Send JS/TS files to server and process response
        if: env.HAS_FILES == 'true'
        run: |
          echo "=== Sending JS/TS files to server ==="

          # Initialize a flag to track if we got any valid responses
          RECEIVED_VALID_RESPONSE=false

          for file in $CHANGED_FILES; do
            echo ""
            echo "---- Processing: $file ----"
            
            if [ ! -f "$file" ]; then
              echo "File $file doesn't exist, skipping"
              continue
            fi
            
            echo "Reading file content..."
            CONTENT=$(cat "$file" | jq -Rs .) || {
              echo "Failed to read content for $file"
              continue
            }
            
            # Create JSON payload
            JSON_PAYLOAD=$(jq -n \
              --arg file_path "$file" \
              --argjson content "$CONTENT" \
              '{file_path: $file_path, content: $content}')
            
            echo "Sending to server..."
            
            HTTP_RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
              https://42459725c5d9.ngrok-free.app/inputCode \
              -H "Content-Type: application/json" \
              -H "ngrok-skip-browser-warning: true" \
              -d "$JSON_PAYLOAD")
            
            HTTP_STATUS=$(echo "$HTTP_RESPONSE" | tail -n1 | cut -d: -f2)
            RESPONSE_BODY=$(echo "$HTTP_RESPONSE" | sed '$d')
            
            echo "HTTP Status: $HTTP_STATUS"
            echo "Server response: $RESPONSE_BODY"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Successfully sent $file"
              
              # Check if response contains JSON (basic check)
              if echo "$RESPONSE_BODY" | jq empty 2>/dev/null; then
                echo "Valid JSON response received, saving for processing..."
                echo "$RESPONSE_BODY" > "server_response_${file//\//_}.json"
                RECEIVED_VALID_RESPONSE=true
              else
                echo "Response is not valid JSON, skipping file creation for $file"
              fi
            else
              echo "Failed to send $file (HTTP $HTTP_STATUS)"
            fi
            
            echo "------------------------"
          done

          echo "RECEIVED_VALID_RESPONSE=$RECEIVED_VALID_RESPONSE" >> $GITHUB_ENV

      - name: Create test files from server response
        if: env.HAS_FILES == 'true' && env.RECEIVED_VALID_RESPONSE == 'true'
        run: |
          echo "=== Creating test files from server responses ==="

          # Create the robust file processor script with malformed JSON handling
          cat > process_responses.js << 'EOF'
          const fs = require('fs');
          const path = require('path');

          /**
           * Converts malformed JSON string with escaped characters to proper JSON
           * @param {string} malformedJsonString - The malformed JSON string from server
           * @returns {object} - Clean parsed JSON object
           */
          function cleanAndParseJson(malformedJsonString) {
            try {
              let outputContent = '';
              
              // Method 1: Try to parse as valid JSON first
              try {
                const outerJson = JSON.parse(malformedJsonString);
                if (outerJson.output) {
                  outputContent = outerJson.output;
                } else {
                  throw new Error('No output field found');
                }
              } catch (parseError) {
                // Method 2: Handle malformed outer JSON with raw newlines
                console.log('⚠️ Outer JSON is malformed, extracting manually...');
                
                // Pre-process: Find the output field and extract its content
                const outputStart = malformedJsonString.indexOf('"output":');
                if (outputStart === -1) {
                  throw new Error('No "output" field found');
                }
                
                // Find the opening quote after "output":
                const valueStart = malformedJsonString.indexOf('"', outputStart + 9);
                if (valueStart === -1) {
                  throw new Error('Malformed output field');
                }
                
                // Find the end by looking for the pattern: quote followed by newline and closing brace
                let valueEnd = -1;
                
                // Look for the content between quotes
                for (let i = valueStart + 1; i < malformedJsonString.length; i++) {
                  const char = malformedJsonString[i];
                  const nextChar = malformedJsonString[i + 1];
                  
                  // Look for the end pattern: "\n}\n or "}
                  if (char === '"' && (nextChar === '\n' || nextChar === '\r')) {
                    const remaining = malformedJsonString.substring(i + 1).trim();
                    if (remaining.startsWith('}')) {
                      valueEnd = i;
                      break;
                    }
                  }
                }
                
                if (valueEnd === -1) {
                  // Fallback: find the last quote before a closing brace
                  const lastBrace = malformedJsonString.lastIndexOf('}');
                  const lastQuote = malformedJsonString.lastIndexOf('"', lastBrace);
                  if (lastQuote > valueStart) {
                    valueEnd = lastQuote;
                  } else {
                    throw new Error('Could not find end of output field');
                  }
                }
                
                // Extract the raw content
                outputContent = malformedJsonString.substring(valueStart + 1, valueEnd);
              }
              
              // Clean the extracted content
              if (!outputContent) {
                throw new Error('No content extracted from output field');
              }
              
              // Remove "json\n" or "json\\n" prefix
              outputContent = outputContent.replace(/^json\n/, '').replace(/^json\\n/, '').replace(/^json/, '');
              
              // Handle the content step by step
              let cleanedContent = outputContent;
              
              // If we have raw newlines (not escaped), we need to handle them carefully
              if (cleanedContent.includes('\n') && !cleanedContent.includes('\\n')) {
                // Split by actual newlines and rejoin with escaped newlines for processing
                const lines = cleanedContent.split('\n');
                cleanedContent = lines.join('\\n');
              }
              
              // Now process escaped characters
              // Handle escaped quotes first
              cleanedContent = cleanedContent.replace(/\\"/g, '"');
              
              // Convert escaped newlines back to actual newlines
              cleanedContent = cleanedContent.replace(/\\n/g, '\n');
              
              // Handle escaped backslashes
              cleanedContent = cleanedContent.replace(/\\\\/g, '\\');
              
              // Clean up boundaries
              cleanedContent = cleanedContent.trim();
              
              // Ensure proper JSON structure
              if (!cleanedContent.startsWith('{')) {
                const braceIdx = cleanedContent.indexOf('{');
                if (braceIdx !== -1) {
                  cleanedContent = cleanedContent.substring(braceIdx);
                }
              }
              
              if (!cleanedContent.endsWith('}')) {
                const lastBraceIdx = cleanedContent.lastIndexOf('}');
                if (lastBraceIdx !== -1) {
                  cleanedContent = cleanedContent.substring(0, lastBraceIdx + 1);
                }
              }
              
              // Attempt to parse
              let cleanJson;
              try {
                cleanJson = JSON.parse(cleanedContent);
              } catch (finalParseError) {
                console.log('🔧 Attempting final JSON repair...');
                
                // Remove trailing commas before closing braces/brackets
                let repairedContent = cleanedContent.replace(/,(\s*[}\]])/g, '$1');
                
                try {
                  cleanJson = JSON.parse(repairedContent);
                } catch (stillFailed) {
                  console.error('❌ Could not repair JSON. Original error:', finalParseError.message);
                  console.error('❌ Content preview:', cleanedContent.substring(0, 200));
                  throw finalParseError;
                }
              }
              
              console.log('✅ Successfully cleaned and parsed JSON');
              return cleanJson;
              
            } catch (error) {
              console.error('❌ Error cleaning JSON:', error.message);
              console.error('❌ Input preview:', malformedJsonString.substring(0, 300) + '...');
              throw error;
            }
          }

          function createTestFiles(input, folder = 'tests') {
            let filesJson;

            // If input is a string, try to clean and parse it
            if (typeof input === 'string') {
              // Remove ```json and ``` wrapping first
              input = input.replace(/^```json\s*/i, '').replace(/```$/i, '').trim();

              try {
                // Try regular JSON parse first
                filesJson = JSON.parse(input);
              } catch (err) {
                console.log('Regular JSON parse failed, trying robust cleaning...');
                try {
                  // Use our robust JSON cleaner
                  filesJson = cleanAndParseJson(input);
                } catch (cleanErr) {
                  console.error('Failed to parse JSON even with cleaning:', cleanErr);
                  return;
                }
              }
            } else if (typeof input === 'object') {
              filesJson = input;
            } else {
              console.error('Input must be a JSON string or object');
              return;
            }

            // Ensure the folder exists
            if (!fs.existsSync(folder)) {
              fs.mkdirSync(folder, { recursive: true });
              console.log(`Created folder: ${folder}`);
            }

            // Create or overwrite files
            for (const [filename, content] of Object.entries(filesJson)) {
              const filePath = path.join(folder, path.basename(filename));

              try {
                fs.writeFileSync(filePath, content, 'utf8');
                console.log(`Created/Updated file: ${filePath}`);
              } catch (err) {
                console.error(`Failed to write file ${filePath}:`, err);
              }
            }
          }

          // Process all server response files
          const responseFiles = fs.readdirSync('.').filter(file => file.startsWith('server_response_') && file.endsWith('.json'));

          if (responseFiles.length === 0) {
            console.log('No server response files found');
            process.exit(0);
          }

          responseFiles.forEach(responseFile => {
            console.log(`\nProcessing ${responseFile}...`);
            try {
              const responseContent = fs.readFileSync(responseFile, 'utf8');
              console.log(`Response content preview: ${responseContent.substring(0, 100)}...`);
              createTestFiles(responseContent);
              
              // Clean up the temporary response file
              fs.unlinkSync(responseFile);
              console.log(`Cleaned up ${responseFile}`);
            } catch (err) {
              console.error(`Error processing ${responseFile}:`, err);
            }
          });
          EOF

          # Run the processor
          node process_responses.js

          # Clean up the processor script
          rm process_responses.js

      - name: Configure Git
        if: env.HAS_FILES == 'true' && env.RECEIVED_VALID_RESPONSE == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Commit and push generated test files
        if: env.HAS_FILES == 'true' && env.RECEIVED_VALID_RESPONSE == 'true'
        run: |
          echo "=== Committing generated test files ==="

          # Make sure tests folder exists and is not empty
          if [ -d "tests" ] && [ "$(ls -A tests)" ]; then
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"

            # Ensure we are on the correct branch
            git checkout main

            # Add the generated files
            git add tests/

            # Only commit if there are changes
            if git diff --cached --quiet; then
              echo "No changes to commit"
            else
              git commit -m "Add generated test files from server response"
              # Push using git push origin
              git push origin main
              echo "Successfully committed and pushed test files"
            fi
          else
            echo "No test files were created"
          fi

      - name: No JS/TS files found
        if: env.HAS_FILES == 'false'
        run: |
          echo "No JavaScript/TypeScript files found in last commit"
          echo "Only .js, .jsx, .ts, .tsx files are processed"
